
<img width="1280" alt="image" src="https://github.com/muunhwi/red_black_tree/assets/110352078/442b07ee-d8c5-49e0-a41f-1cf9710b02aa">

- 레드블랙트리
    - 기존 이진 탐색 트리의 최악의 경우를 예방하고자, 삽입 삭제 시 내부적인 규칙으로 균형을 맞추는 트리
    - 삽입과 삭제가 발생하면 무조건 5가지 규칙을 지켜야 하며, 하나라도 틀어지면 레드 블랙 트리가 아님
    - 기본적으로 각 노드에 색깔(레드, 블랙)을 지정하고, 새로운 노드가 삽입되거나, 삭제 될 때 이 색깔 규칙이 지켜지는 지를 판단하여 균형을 잡는다.
    - 마찬가지로 이진 탐색 트리 범주의 하나 이기 때문에 이진 탐색 트리의 규칙 또한 지켜져야 한다.
    
- 레드블랙트리의 규칙
    1. 트리 상의 모든 노드들은 레드 또는 블랙의 색깔을 가져야 한다. 
    2. 루트 노드는 무조건 블랙이다. 
    3. 리프 노드는 항상 nil  노드와 연결돼 있어야 한다. 또한 nil  노드는 항상 블랙이다.
    4. 레드 노드의 자식으로 레드 노드가 올 수 없다.
    5. 임의의 노드에서 모든 nil  노드 까지의 경로에 블랙 노드의 개수가  같아야 한다.

- 레드 블랙 트리 삽입 시 고려할 사항
    - 회전 함수를 명확하게 구현해야 한다.
        - “어떤 노드”를 삽입할 때 기준은 항상 부모이거나 할아버지 노드이다.
        - 또한 각 노드마다 부모 노드에 대한 포인터를 가지고 있기 때문에 부모 연결 또한 적절히 수행해주어야 한다.
        - 할아버지 노드와 부모 노드의 위치가 변경되는데 이 때 삽입된 “어떤 노드” 의 형제노드가 존재한다면, 해당 형제 노드를 적절한 위치로 이동 시켜 주어야 한다.
    - 삽입 후 “레드 레드” 문제가 발생하면 고려해야할 3가지
         CASE 1: 부모가 레드이고, 삼촌도 레드인 경우
         CASE 2:부모가 레드인데, 나 자신이 부모로부터 대각선으로 위치해 있는 경우
         CASE 3: 부모가 레드이고, 삼촌이 블랙인 경우

레드 블랙 트리에서 삭제 처리는 이진 탐색 트리와 기본 토대는 같지만 추가적인 균형작업이 들어가서 매우 복잡해진다. 
기본적으로 이진 탐색 트리에서 삭제를 수행할 때 자식이 둘 존재하나 아니냐로 로직이 달라지는데. 
레드 블랙 트리 또한 비슷하지만 결국 자식이 없거나 하나인 노드만을 삭제하는 것으로 귀결된다. 
삭제하는 노드의 자식이 둘 이라면 왼쪽 자식 노드부터 가장 큰 값 또는 오른쪽 자식 노드에서 부터 가장 작은 값을 스왑해주고 값이 스왑된 단말 노드를 삭제하게 된다. 
이 때 삭제 되는 노드가 레드라면 단순히 삭제처리를 해주면 된다.  하지만 블랙이라면 여러가지 케이스로 나뉘게 된다.

삭제할 노드가 블랙이고, 자식이 레드라면 자식을 블랙으로 단순히 변경만 하면 된다
하지만 자식이 블랙이라면 형제나 부모를 보고 판단해야한다.
결국 삭제를 수행하게 되면 왼쪽이든 오른쪽이든 블랙 개수가 하나 감소하게 되고 이를 균형잡아줘야 하기 때문이다. 
균형을 잡을 때 삽입과 마찬가지로 회전을 통해 다른 영역의 블랙 노드를 끌어오던가, 아니면 다른 영역의 노드를 레드로 만들어서 블랙을 감소시키고, 재귀적으로 균형을 잡는 방식으로 처리를 하게 된다.

- **대략 10000 개의 데이터를 삽입, 삭제 996회 수행 표**

```cpp
                       Name |              Average |              Max     |                  Min |                 Call |

BTREE RANDOM INSERT         |             1371.0㎲ |            10762.3㎲ |              807.3㎲ |                  996 |
RBTREE RANDOM INSERT        |             1544.4㎲ |            15062.3㎲ |              943.9㎲ |                  996 |

BTREE RANDOM DELETE         |             1484.4㎲ |            18421.2㎲ |              920.3㎲ |                  996 |
RBTREE RANDOM DELETE        |             1404.0㎲ |            11397.1㎲ |              843.7㎲ |                  996 |

BTREE ASC INSERT            |           146343.4㎲ |           338039.5㎲ |           111652.0㎲ |                  996 |
RBTREE ASC INSERT           |             1220.6㎲ |            10729.2㎲ |              767.7㎲ |                  996 |

BTREE DESC DELETE           |           583424.1㎲ |          1497712.7㎲ |           190704.5㎲ |                  996 |
RBTREE DESC DELETE          |              786.9㎲ |             3035.9㎲ |              427.1㎲ |                  996 |

```

- 레드 블랙 트리(RBTree)와 이진 탐색 트리(BTree)의 성능을 비교
    1. **랜덤 삽입 (Random Insert)**
        - **BTREE RANDOM INSERT:** 평균 1371.0㎲
        - **RBTREE RANDOM INSERT:** 평균 1544.4㎲
        - **비교:** RBTREE의 성능이 약 1.13배 더 나쁨 (1544.4 / 1371.0)
    2. **랜덤 삭제 (Random Delete)**
        - **BTREE RANDOM DELETE:** 평균 1484.4㎲
        - **RBTREE RANDOM DELETE:** 평균 1404.0㎲
        - **비교:** RBTREE의 성능이 약 1.06배 더 좋음 (1484.4 / 1404.0)
    3. **순차 삽입 (Ascending Insert)**
        - **BTREE ASC INSERT:** 평균 146343.4㎲
        - **RBTREE ASC INSERT:** 평균 1220.6㎲
        - **비교:** RBTREE의 성능이 약 119.91배 더 좋음 (146343.4 / 1220.6)
    4. **내림차순 삭제 (Descending Delete)**
        - **BTREE DESC DELETE:** 평균 583424.1㎲
        - **RBTREE DESC DELETE:** 평균 786.9㎲
        - **비교:** RBTREE의 성능이 약 741.29배 더 좋음 (583424.1 / 786.9)


